//------------// Introduction to Programming Using Java: An Object-Oriented Approach//	Arnow/Weiss//------------//------------// Chapter 12 / GUI Supplement / Page 618//	The Mancala Applet//------------ //------------// Notes//	- This applet may be run by opening the file '.html'//		in a browser or appletviewer.//	- To simplify building this applet, we have included several//		classes in this source file. In particular, the Player//		class for this applet is by necessity different than the//		one used in the text-based application (see the discussion//		on page 599).//	- !!!! Differences from the code in the text !!!!//		The declaration of the currentPlayer instance variable//			in clas Mancala Applet is incorrectly followed in//			the text by a single quote mark (') rather than a //			semicolon (;).//      The statement://				for (int playerNum = 0; playerNum < 2; playerNum++) //			in the MancalaCanvas constructor is missing a { in the text//			In addition, the next statement after the above for loop should//			be://				for (int pitNum = 0; pitNum < MancalaBoard.playingPits; pitNum++) {//			and as a result there should be one additional (that is a third)//			closing brace (}} at the end of the method.//------------import java.awt.*;import java.awt.event.*;import java.applet.*;public class MancalaApplet extends Applet                          implements ActionListener {    public void init() {             // Set up game for play.        board = new MancalaBoard();  // Creates board and initializes                                       //       it for play.        board.setUpForPlay();        players = new Player[2];			// Players        players[0] = new Player("", 0);    // No names used in                                            //       applet        players[1] = new Player(null, 1);  // Computer        currentPlayer = 0;        // Set up display.        setLayout(new BorderLayout());        Panel p = new Panel();                  // Top        add("North", p);        moveButton[1] = new Button("Computer");        moveButton[1].addActionListener(this);  // Handle own                                                 //       buttons.        moveButton[1].setEnabled(false);        p.add(moveButton[1]);        p.add(new Label("Player 1"));        p = new Panel();                        // Center        add("Center", p);        canvas = new MancalaCanvas(board);        p.add(canvas);        moveList = new List();        p.add(moveList);        p = new Panel();                        // Bottom        add("South", p);        moveButton[0] = new Button("You");        moveButton[0].addActionListener(this);  // Handle own                                                 //       buttons.        p.add(moveButton[0]);        p.add(new Label("Player 0"));    }    public void actionPerformed(ActionEvent ae) {		int theMove = 0;        if (currentPlayer == 0) {           // Human player			theMove = canvas.getChosenPit() + 1;            if (theMove == 0)				return ;		}		else  // Computer player			theMove = players[1].selectAMove(board);		moveList.addItem("Player " + currentPlayer + ": " + theMove);			// Determine next player and enable/disable buttons accordingly.		if (!board.doTheMove(currentPlayer, theMove))			currentPlayer = Math.abs(currentPlayer-1);		moveButton[currentPlayer].setEnabled(true);		moveButton[Math.abs(currentPlayer-1)].setEnabled(false);		canvas.resetChosenPit();  // Clear human player's pit                                     //      choice.		if (board.gameOver()) {  // Determine winner			int stonesOf0 = board.stonesInMancala(0);			int stonesOf1 = board.stonesInMancala(1);			if (stonesOf0 > stonesOf1)  //  and announce winner.				moveList.addItem("Player 0 wins");			else if (stonesOf1 > stonesOf0)				moveList.addItem("Player 1 wins");			else				moveList.addItem("Tie");		}		moveList.makeVisible(moveList.getItemCount()-1);	}	// Game stuff	private MancalaBoard board;	private Player [] players;	private int currentPlayer;	// Display stuff	private MancalaCanvas canvas;	private Button [] moveButton = new Button[2];	private List moveList;}class MancalaCanvas extends Canvas                       implements MouseListener {    public MancalaCanvas(MancalaBoard board) {        this.board = board;        setSize(CanvasWidth, CanvasHeight);        addMouseListener(this);				// We'll handle our own mouse events.        // Determine and save centers of the playing pits (for paintStones).        pitXCenter = new int[2][MancalaBoard.playingPits];        pitYCenter = new int[2][MancalaBoard.playingPits];        for (int playerNum = 0; playerNum < 2; playerNum++) {			for (int pitNum = 0; pitNum < MancalaBoard.playingPits; pitNum++) {				int x = CanvasBorder + BoardBorder + 					FullMancalaWidth +					// Fixed horiz. spacing					((board.playingPits - 1) - pitNum) *                     FullPitWidth;						// Skips preceding pits				int y = CanvasBorder + BoardBorder;		// Fixed vert. 														//      spacing				if (playerNum == 0)						// 0's pits are on bottom.					y += MancalaHeight - PitHeight;		// Space 														//      downwards.				// We now have left/top edge of pits				pitXCenter[playerNum][pitNum] = x + PitXRadius;				pitYCenter[playerNum][pitNum] = y + PitYRadius;			}		}	}	public void paint(Graphics g) {		// Paint board.		Color c = g.getColor();		g.setColor(BoardColor);		g.fillRect(CanvasBorder, CanvasBorder, BoardWidth, 				BoardHeight);		g.setColor(c);		g.drawRect(CanvasBorder, CanvasBorder, BoardWidth, 				BoardHeight);		// The pits, mancalas, and stones		for (int playerNum = 0; playerNum < 2; playerNum++) {			paintMancala(g, playerNum, board.stonesInMancala(playerNum));			for (int pitNum = 0; pitNum < board.playingPits; pitNum++)				paintPit(g, playerNum, pitNum,							board.stonesInPit(playerNum, 							pitNum+1));		}	}	private void paintMancala(Graphics g, int playerNum, int stones) {		int x = CanvasBorder + BoardBorder;  // Fixed horiz. spacing		int y = CanvasBorder + BoardBorder;  // Fixed vert. spacing	    if (playerNum == 0)              // 0's mancala on right			x += FullMancalaWidth +				   board.playingPits * FullPitWidth;  // Skip past 					                                  //  pits.        // Set color and draw mancala.        Color c = g.getColor();        g.setColor(PitColor);        g.fillOval(x, y, MancalaWidth, MancalaHeight);        g.setColor(c);        g.drawOval(x, y, MancalaWidth, MancalaHeight);        paintStones(g, x, y, MancalaXRadius,                     MancalaYRadius, stones);    }	private void paintPit(Graphics g, int playerNum,                       int pitNum, int stones) {        // Determine pit's location.        int pitsToSkip;        if (playerNum == 0)  // 0's pits are displayed in reverse (5 .. 0)           pitsToSkip = MancalaBoard.playingPits - 1 -                         pitNum;        else                 // 1's pits are displayed 0 .. 5           pitsToSkip = pitNum;        int x = CanvasBorder + BoardBorder +                 FullMancalaWidth +                                            // Fixed horiz. spacing                pitsToSkip * FullPitWidth;  // Skips preceding                                             //      pits        int y = CanvasBorder + BoardBorder; // Fixed vert.                                             //      spacing        if (playerNum == 0)  // 0's pits are on bottom.           y += MancalaHeight - PitHeight;  // Spaces to bottom                                             //      row        // Select color and draw the pit.        Color c = g.getColor();        if (playerNum == 0 && pitNum == chosenPit)           g.setColor(ChosenPitColor);        else           g.setColor(PitColor);        g.fillOval(x, y, PitWidth, PitHeight);        g.setColor(c);        g.drawOval(x, y, PitWidth, PitHeight);        paintStones(g, x, y, PitXRadius, PitYRadius,                     stones);    }    private void paintStones(Graphics g,               int ovalX, int ovalY,  // Upper-left corner of def rect.               int ovalXRadius, int ovalYRadius,               int stones) {        int ovalCenterX = ovalX + ovalXRadius;        int ovalCenterY = ovalY + ovalYRadius;        // x radius (width) and y radius (height) of inner oval        int innerXRadius = ovalXRadius - StoneRadius;        int innerYRadius = ovalYRadius - StoneRadius;        // Their squares        		int innerXRadiusSq = (int)Math.pow(innerXRadius, 2);        int innerYRadiusSq = (int)Math.pow(innerYRadius, 2);        // Used to keep track of centers of stones already positioned        int [] stoneCenterX = new int[stones];        int [] stoneCenterY = new int[stones];        for (int s = 0; s < stones; s++) {			boolean done = false;			int possibleCenterX=0; // Java forces us to initialize.			int possibleCenterY=0; // Java forces us to initialize.			// Generate possible stone centers until we get a good one.			while (!done) {				done = true;  // Assume we'll find a point this time through                              //      loop.				// Generate a candidate for the y coordinate of our stone's center.				// Generate a random value in the range 0 .. 2*innerRadius				possibleCenterY = (int)(Math.random() * 2*innerYRadius);				//      and scale the value to -innerYRadius .. innerYRadius.				possibleCenterY -= innerYRadius;				// Now that y is fixed, generate a candidate for x within the bounds set				//      by our choice for y.				// Solve the equation of the oval for x (y is known).				int maxCenterX =					(int)Math.sqrt(innerXRadiusSq -						(innerXRadiusSq * 							Math.pow(possibleCenterY, 2) /							innerYRadiusSq));				// We have maximum value for x; now generate value in range 0 .. 				//      2*maxCenterX.				possibleCenterX = (int)(Math.random() * 						              2*maxCenterX);				// Scale to -maxCenterX .. maxCenterX;				possibleCenterX -= maxCenterX;				// Now check that we're not too close to any other stone position.				for (int i = 0; i < s; i++) {					// If our candidate position is too close to another stone, discard it and 					//      try again.					if (distance(possibleCenterX, possibleCenterY,							stoneCenterX[i], stoneCenterY[i]) < 							StoneRadius)						done = false; // Forces us back into the while (!done) loop				}			}			// The variable done has remained true - We have obtained a new stone position 			//      with center possibleCenterX, possibleCenterY - remember it.			stoneCenterX[s] = possibleCenterX;			stoneCenterY[s] = possibleCenterY;			    // Determine upper-left edge of def rect by subtracting	        //      stone's readius from its center's x/y coordinates.			int definingX = ovalCenterX + (possibleCenterX - 							StoneRadius);			int definingY = ovalCenterY + (possibleCenterY - 							StoneRadius);			// Select color and draw the stone.			Color c = g.getColor();			g.setColor(StoneColor[s % StoneColor.length]); 												// cycle through colors			g.fillOval(definingX, definingY, StoneWidth, 					StoneWidth);			g.setColor(c);			g.drawOval(definingX, definingY, StoneWidth, 					StoneWidth);		}	}	public void mouseClicked(MouseEvent me) {		int x = me.getX(),  // Get the coordinates of the click		y = me.getY();      //      from the MouseEvent object.		// Go through each of 0's (human's) pits and check if mouse was		//      clicked within its boundaries		for (int pitNum = 0; pitNum < board.playingPits; pitNum++)			if (liesInsidePit(x, y, pitNum)) {				chosenPit = pitNum;  // Will cause pit to be highlighted.				repaint();           // Redisplay to show choice.			}	}	// Empty methods	public void mousePressed(MouseEvent e) {}	public void mouseReleased(MouseEvent e) {}	public void mouseEntered(MouseEvent e) {}	public void mouseExited(MouseEvent e) {}	public int getChosenPit() {		return chosenPit;	}	public void resetChosenPit() {	    chosenPit = -1;	    repaint();	}	// Calculates standard distance between two points.	private int distance(int x1, int y1, int x2, int y2) {		return (int)Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));	}	// Plugs x and y into equation of oval and determines if the point lies within the edge.	private boolean liesInsidePit(int x, int y, int pitNum) {	    double xTerm = Math.pow((x -						pitXCenter[0][pitNum]) * PitYRadius, 2);		double yTerm = Math.pow((y -						pitYCenter[0][pitNum]) * PitXRadius, 2);		double edgeTerm = Math.pow(PitYRadius * PitXRadius, 2);		return xTerm + yTerm <= edgeTerm;	}	// Game stuff	private MancalaBoard board;	// Display stuff	private int chosenPit = -1;	private int pitXCenter[][];	private int pitYCenter[][];	private static final int	    StoneWidth = 8,		StoneHeight = StoneWidth,	    StoneRadius = StoneWidth / 2,	    PitWidth = StoneWidth * 6,	    PitSpacing = PitWidth / 4,	    FullPitWidth = PitWidth + PitSpacing,	    PitHeight = (int)(PitWidth * 1.25),	    PitXRadius = PitWidth / 2,	    PitYRadius = PitHeight / 2,	    MancalaWidth = PitWidth,	    FullMancalaWidth = MancalaWidth + PitSpacing,	    MancalaHeight = 2 * PitHeight + PitSpacing,	    MancalaXRadius = MancalaWidth / 2,	    MancalaYRadius = MancalaHeight / 2,	    BoardBorder = PitSpacing,	    BoardWidth = 2 * BoardBorder +                FullMancalaWidth +				MancalaBoard.playingPits * FullPitWidth +				MancalaWidth,	    BoardHeight = MancalaHeight + 2 * BoardBorder,	    CanvasBorder = BoardBorder,	    CanvasWidth = BoardWidth + 2 * CanvasBorder,	    CanvasHeight = BoardHeight + 2 * CanvasBorder;    private static final Color		ChosenPitColor = Color.white,        StoneColor[] = {           Color.red, Color.green,           Color.black, Color.orange,           Color.cyan, Color.yellow        },        BoardColor = new Color(255, 234, 203),        PitColor = new Color(204, 187, 163);}class Player {    Player(String name, int playerNum) {        this.name = name;        this.playerNum = playerNum;    }    String getName() {        if (name != null)            return name;        else            return "Computer";    }    int getPlayerNum() {        return this.playerNum;    }	int selectAMove(MancalaBoard board) {     	// Need to determine best move    	int bestMove = -1;									// No best move initially    	int repeatMove = -1;								// ... or go again    	int maxNewStones = -1;								// ... no move has added stones to the mancala    	// Trying the possible moves    	for (int pitNum = 1; pitNum <= board.playingPits; pitNum++) {    		if (board.stonesInPit(playerNum, pitNum) != 0) {				// Only non-empty pits may be moved from    			MancalaBoard testBoard = board.makeACopy();					// Make a copy of the board ...    			boolean goAgain = testBoard.doTheMove(playerNum, pitNum);	// ... and try the move on the board copy    			if (goAgain)												// If move allows us to go again...    				repeatMove = pitNum;									//	... remember the move       			int newStones = testBoard.stonesInMancala(playerNum) -		// See how many stones this move added    								board.stonesInMancala(playerNum);		//	added to our mancala    			if (newStones > maxNewStones) {								// More stones than so far?    				maxNewStones = newStones;								//	remember how many and ...    				bestMove = pitNum;										//	... the move	    		}    		}      	}	    // Tried all posibilities, return the best one    	if (maxNewStones > 1) 								// > 1 means a multi-stone capture occurred    		return bestMove;    	else if (repeatMove != -1) 							// barring that use a ‘go again’    		return repeatMove;    	else    		return bestMove;								// 1 or possibly 0 stones added, oh well!    }	String name;	int playerNum;}